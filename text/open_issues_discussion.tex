\section{Open Issues and Discussion}

In this paper we have provided an algorithm for translating \ears requirements
into \ltl. The algorithm operates in two phases: it first translates every \ears
requirement present in the specification taking into consideration only local
information (\sect\ref{sec:formalization}), while a second pass adds some of the
contextual information present in the totality of the requirements
(\sect\ref{sec:context}).

We do not presume our translation if generalizable for all other code
synthesizers or other tools that consume \ltl specifications (such as model
checkers). Nonetheless, we are convinced that the \emph{local} and
\emph{context} translation phases we have identified in our translation are
generally necessary. Being aimed at requirements engineers that deal
mostly with natural language, it is expectable that some of the information
exposed in an \ears specification is implicitly stated. While for humans this does not pose a major
problem, it is a showstopper for computers. By breaking down the translation
into phases and bringing that implicit knowledge to the foreground while
encoding into \ltl formulas, we believe a part of this problem is solvable in
practice.

Note that other contextual information could be retrieved from an \ears
specification and made explicit. Such information could include \eg finding
similar terms that denote the same entity, automatically deriving a notion of
state of the system and even explicitly deriving the behavior (\eg as state
machines) from \ears requirements. Such state machines could \eg be partially
built using the static analysis algorithm we have presented in
\sect\ref{sec:context}.

From a more abstract viewpoint, the translation we present here is also
potentially also an enabler for the formal verification of and test case
generation from \ears specifications. Which kind of model-checker or test-case
generator specific information would be required to be added to the \ltl we
currently produce is beyond the scope of this paper. Research in this direction
could marry the increasing power of formal verification tools with the
proposals of the \ears community.


% The results obtained by utilizing EARs in the context of IETS3 are promising.
% In particular, EARs being utilized, 1) as a structured requirements writing
% language as opposed to writing in natural language and, 2) to do automatic
% code synthesis from EARs specifications. However, using EARs in our context
% have also led us to have a list of interesting open issues and observations.
% The following is a non-exhaustive list of open issues and observations of EARs
% being utilized in the context of IETS3, \begin{itemize} \item Limited scope of
% translation controller generation. E.g. dealing with parameters is not taken
% care of. (Is this an extensibility issue? can we solve it by extending the
% language with parameters? is this an observation?) \item Covering the gap
% between informal and formal -- how far can we get without losing implicit
% information. Most of the organizations write requirements in an
% unstructured/natural language. one of our observations is that it is difficult
% for the companies to view immediate benefits of adopting a structured/template
% language like EARs. For that purpose, we would like to investigate further on
% how to close the gap between natural/informal requirements and
% structured/template language like EARs so that there is a minimal loss of
% information.
% \item How generalizable is our approach? At present, we have applied our
% approach for automatic code synthesis in the controller domain. We would like
% to investigate if our approach can be generalized enough and can be utilized
% in other domains (e.g., writing test cases).
% \item Model checking is the next step. We would further like to investigate
% how EARs can be helpful in performing the model checking.
% \item Order is often important. It can be deduced from the context, but should
% there be an implicit order? At present, we have written requirements using
% EARs for controller generation purpose where the writing in a particular order
% might not that important. However, it would be interesting to investigate
% further as to how to prioritize/order the requirements when written in EARs
% for other domains? FOr instance, this might be helpful in order to run test
% suites attached to high-priority requirements.
% \item Requirements are often not independent, we have observed during our
% investigations that there is not an explicit way of having/managing
% dependencies between requirements when written in EARs.
% \item At present, EARs allow only discrete events (at any instance in time as
% binary ON/OFF), how to have EARs for continuous (real-time) events in time?
% \end{itemize}